# 工具及使用

* 为了应对各种题目的编程，需要理解哪些基本工具？

|    工具    |  工具类型  | 工具属性 |                           基本操作                           |
| :--------: | :--------: | :------: | :----------------------------------------------------------: |
|    数组    |  线性结构  |          |                             遍历                             |
|    队列    |  线性结构  |          |                          入队、出队                          |
|     栈     |  线性结构  |          |                          入栈、出栈                          |
|    链表    |  线性结构  |          |                             遍历                             |
|     树     | 半线性结构 |          |            前序遍历、中序遍历、后序遍历、层序遍历            |
|   二叉树   | 半线性结构 |          |            前序遍历、中序遍历、后序遍历、层序遍历            |
| 二叉查找树 |            |          | 前序遍历、中序遍历、后序遍历、层序遍历、插入、查找、删除、找父节点、求最大值、求最小值 |
| 二叉平衡树 | 半线性结构 |          | 前序遍历、中序遍历、后序遍历、层序遍历、插入、删除、旋转、查前驱、查后继 |
|   字典树   | 半线性结构 |          |                             剪枝                             |
|     图     | 非线性结构 |          |                          建图、遍历                          |

* 如何实现对这些工具的基本操作？

|    工具    |   操作   |                             实现                             |
| :--------: | :------: | :----------------------------------------------------------: |
|   二叉树   | 前序遍历 |         基于栈的前序遍历算法、基于递归的前序遍历算法         |
|            | 中序遍历 | 基于栈的中序遍历算法、基于递归的中序遍历算法、基于双色标记的中序遍历算法 |
|            | 后序遍历 |         基于栈的后序遍历算法、基于递归的后序遍历算法         |
|            | 层序遍历 |        基于队列的层序遍历算法、基于递归的层序遍历算法        |
| 二叉查找树 |   插入   |                                                              |
| 二叉查找树 |   查找   |                                                              |
| 二叉查找树 |   删除   |                                                              |
| 二叉查找树 | 找父节点 |                                                              |
|     图     |   建图   |                                                              |
|     图     |   遍历   | 基于递归的dfs算法、基于迭代的dfs算法、基于递归的bfs算法、基于迭代的bfs算法 |

# 应用方法

* 基于这些工具，通过设计一些算法可以解决实际问题。为了更好地解决实际问题，如何理解算法？
>1. 注意点：图表中的递归和第三列使用方法中的具体方法之间的关系不是归纳，是逻辑关系

|           应用场景           |        算法名称        |                            元思路                            | 算法思想 |  场景思路  | 算法数据结构 | 算法算法结构 | 算法执行过程 | 场景数据结构 | 场景算法结构 | 场景执行过程 | 归纳过程 | 算法 |
| :--------------------------: | :--------------------: | :----------------------------------------------------------: | :------: | :--------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :------: | :--: |
|                              |     迪杰斯特拉算法     |                                                              |   贪心   |            |              |              |              |              |              |              |          |      |
|                              |      弗洛伊德算法      |                                                              |          |            |              |              |              |              |              |              |          |      |
|                              |      A星寻路算法       |                                                              |          |            |              |              |              |              |              |              |          |      |
|      深度优先搜索一张图      |   基于递归的dfs算法    |                                                              |   dfs    |            |      /       |              |              |              |              |              |          |      |
|      广度优先搜索一张图      |   基于队列的bfs算法    |                                                              |   bfs    |            |      /       |              |              |              |              |              |          |      |
|                              |        Kahn算法        |                                                              |          |            |              |              |              |              |              |              |          |      |
|        前序遍历一棵树        |  基于栈的前序遍历算法  |                                                              |    /     |            |              |              |              |      栈      |     迭代     |              |          |      |
|        中序遍历一棵树        |  基于栈的中序遍历算法  |                                                              |    /     |            |              |              |              |      栈      |     迭代     |              |          |      |
|        后序遍历一棵树        |  基于栈的后序遍历算法  |                                                              |    /     |            |              |              |              |      栈      |     迭代     |              |          |      |
|        层序遍历一棵树        | 基于队列的层序遍历算法 |                                                              |   bfs    |            |      /       |              |              |              |              |              |          |      |
|        前序遍历一棵树        | 基于递归的前序遍历算法 |                                                              |   dfs    |            |      /       |              |              |              |              |              |          |      |
|        中序遍历一棵树        | 基于递归的中序遍历算法 |                                                              |   dfs    |            |      /       |              |              |              |              |              |          |      |
|        后序遍历一棵树        | 基于递归的后序遍历算法 |                                                              |   dfs    |            |      /       |              |              |              |              |              |          |      |
|        层序遍历一棵树        | 基于递归的层序遍历算法 |                                                              |   dfs    |            |      /       |              |              |              |              |              |          |      |
|                              |     单词搜索2算法      |                                                              |          |            |              |              |              |    前缀树    |     递归     |              |          |      |
|     (农行春招)字符串构造     |         算法1          | 用一个数组存放传入字符串，循环遍历该数组。在遍历过程中，向结果数组中添加字符串。当遍历结束后，输出结果数组 |    /     | 该行第三列 |      /       |      /       |      /       |     数组     |     迭代     |    过程1     |  归纳1   |      |
| (农行春招)单元格邻居的最大值 |         算法2          |          根据中心节点的位置，分情况寻找邻居的最大值          |    /     | 该行第三列 |      /       |      /       |      /       |     数组     |     迭代     |    过程2     |  归纳2   |      |
|     (农行春招)字符串加密     |         算法3          |  从前向后遍历字符串的每个字符并按照规则，对每个字符进行转换  |    /     | 该行第三列 |      /       |      /       |      /       |     数组     |     迭代     |    过程3     |  归纳3   |      |

* 如何实现这些算法思想？

| 算法思想 |                             内涵                             | 外延 |
| :------: | :----------------------------------------------------------: | :--: |
|   dfs    | 沿着树的结构一直往深处走，直到找到解或走不下去为止，并且当节点v的所在边都已被探寻过，搜索将回退到发现节点v的那条边的起始节点。这一过程一直进行到已发现从源节点可达的所有节点为止。如果还存在未被发现的节点，则选择其中一个作为源节点并重复上述过程。整个过程反复进行知道所有节点都被访问为止的思路 |      |
|   bfs    | 从根节点开始，沿着树或图的宽度遍历树或图的节点。如果所有节点均被访问，则算法终止的思路 |      |
|   回溯   | 在递归调用dfs前，做一步决策并相应地改变全局的状态。在离开当前函数时，撤销之前在这个函数里做过的决策，即恢复因这个决策而被改变的全局的状态的思路 |      |
|   分治   | 把一个复杂的问题分成两个或更多的相同或相似的子问题，直到最后子问题可以简单的直接求解，并且原问题的解即子问题的解的合并。处理各个小部分的时候可能把部分当作整体去处理，因为部分和整体并没有区别的思路 |      |
| 动态规划 | 把一个复杂的问题分成若干个子问题，按照顺序求解子问题，前一子问题的解为后一子问题的求解提供了有用信息，并且通常包括重叠子问题。在求解任一子问题时，列出各种可能的局部解，通过决策保留最优的局部。依次解决各子问题，直到初始问题的解的思路 |      |
|   贪心   | 只顾眼前最优，从问题的某一个初始解出发逐步逼近给定的目标，每次都仅仅根据当前的已知信息就做出当前最优的选择，并且一旦做出选择，就不再更改的思路 |      |

| 算法思想 | 算法数据结构 | 算法算法结构 | 算法执行过程 | 归纳过程 | 算法 |
| :------: | :----------: | :----------: | :----------: | :------: | :--: |
|   dfs    |    系统栈    |     递归     |              |          |      |
|   bfs    |     队列     |     迭代     |              |          |      |
|   回溯   |              |              |              |          |      |
|   分治   |              |              |              |          |      |
| 动态规划 |              |              |              |          |      |
|   贪心   |              |              |              |          |      |

* 使用到数组的应用场景有哪些？这些场景的特点是什么？(归纳总结类问题)

* 使用到递归的应用场景有哪些？这些场景的特点是什么？(归纳总结类问题)

# 相关思考

* 为什么通过算法的代码很难理解算法的思想？
> 算法的代码是针对具体场景的，其中包括算法思想的实现代码和抽象部分中具体逻辑的实现代码。如果不能从算法的代码中抽象出算法思想的实现代码，那么就无法理解算法思想。

* 为什么知道了算法的思想(dfs)，但就是写不出完整的代码？
>1. 不理解算法思想对应的代码
>2. 算法思想是抽象的，其对应的代码中必然有抽象的部分；同时，没有具体的应用场景，所以不知道抽象部分的逻辑，所以写不出完整的代码

### 一段代码

* 为了理解代码的执行过程，需要考虑哪些方面？
>1. 是否将一段代码看作一个整体。有些代码段实现了一个完整的执行过程，如果一句一句地看这段代码，那么可能很难理解这段代码执行的整体过程
>2. 假如将代码段看作整体，这段代码用到的数据结构有哪些，这些数据结构是否来自代码段外部

* 一段代码在计算机中执行的过程取决于什么？
> 取决于这段代码需要处理的数据结构、内部的数据结构以及这段代码的内部逻辑

* 如何理解一段代码在计算机中的执行过程？
> 需要理解这段代码所处理的数据的数据结构，以及这段代码的内部逻辑

* 通常需要将哪些代码当作一个整体来分析？
> 递归结构；循环代码

### 递归

* 递归的本质是什么？
>1. 是一种算法结构

* 有哪些递归的具体案例？

|   应用场景   |       问题       |                        子问题                        |        上下层子问题间的关系        |
| :----------: | :--------------: | :--------------------------------------------------: | :--------------------------------: |
|   树的遍历   |    遍历整个树    |          遍历整个树、遍历左子树、遍历右子树          |              树的结构              |
| 斐波那契数列 | 求解64的数列的和 | 求解64的数列的和、求解32的数列的和、求解16的数列的和 | 数列的和，即问题结果之间的数学公式 |

* 递归的基本原理是什么？
>1. 工作原理：为了满足需求1，可以操作a+需求2；为了满足需求2，可以操作a+需求3；...；为了满足需求n-1，可以操作a+需求n。为了满足需求n，可以操作b。只要满足了需求b，并且通过操作c满足了需求n-1和需求n的结果之间的关系，那么就可以满足需求n-1，并且通过操作c满足需求n-1和需求n-2的结果之间的关系，那么就可以满足需求n-2，直至满足需求2，并且通过操作c满足需求2和需求1的结果之间关系，那么就可以满足需求1
>2. 需求拆分：为了满足需求1，可以操作a+(需求2，可以操作a+(需求3，可以操作a+(需求4，可以操作a+(...(需求n-1，可以操作a+(需求n))...))))
>3. 最小需求满足：为了满足需求n，可以操作b
>4. 结果递推：((...((((只要满足了需求n，并且通过操作c满足了需求n-1和需求n的结果之间的关系，)那么就满足了需求n-1，并且通过操作c满足了需求n-2和需求n-1的结果之间的关系，)那么就满足了需求n-2，并且通过操作c满足了需求n-3和需求n-2的结果之间的关系，)那么就满足了需求n-3，并且通过操作c满足了需求n-3和需求n-2的结果之间的关系，)...，)那么就满足了需求2，并且通过操作c满足了需求2和需求1的结果之间的关系，)那么就满足了需求1

* 计算机执行递归的逻辑的是什么？
>1. 为了满足需求1，可以操作a+(需求2，可以操作a+(需求3，可以操作a+(需求4，可以操作a+需求5)))
>2. 为了满足需求2，可以操作a+(需求3，可以操作a+(需求4，可以操作a+需求5))
>3. 为了满足需求3，可以操作a+(需求4，可以操作a+需求5)
>4. 为了满足需求4，可以操作a+需求5
>5. 为了满足需求5，可以操作b
>6. 如果操作b，那么满足了需求5
>7. (如果操作b，那么满足了需求5)+操作c，那么满足了需求4
>7. ((如果操作b，那么满足了需求5)+操作c，那么满足了需求4)+操作c，那么满足了需求3
>7. (((如果操作b，那么满足了需求5)+操作c，那么满足了需求4)+操作c，那么满足了需求3)+操作c，那么满足了需求2
>7. ((((如果操作b，那么满足了需求5)+操作c，那么满足了需求4)+操作c，那么满足了需求3)+操作c，那么满足了需求2)+操作c，那么满足了需求1

* 为了让计算机执行递归的逻辑，同时帮助思考，如何编写代码？
>1. 首先，通过操作a将需求1拆分为需求2，假设需求2已经满足，通过操作c可以满足需求1
>2. 其次，将上述过程中的逻辑概括为方法A
>3. 如果需求2的难度比需求3低并且通过不断拆分需求来满足需求2，那么为了满足需求1，可以使用方法A，需要满足需求2，还可以使用方法A，需要满足需求3，还可以使用方法A，直至需要满足需求n
>4. 为了满足需求n，可以使用操作b
>4. 因此，为了满足需求1，可以判断当前需求是否是需求n，如果是，那么使用操作b；否则，使用方法A
>5. 将上述过程中的逻辑概括为方法B，方法B就是递归方法

* **为什么通过以上方法编写代码，可以让计算机执行上述逻辑？**
>1. 当调用递归方法时，计算机将整段递归方法的代码当作一个整体，压入系统栈中
>2. 只有递归方法的整段代码执行完毕，才将这段代码出栈
>3. 只有系统栈中所有节点出栈，递归方法才算调用完毕

* 递归过程中，是什么决定了递归的路径？
>1. 递归方法的参数之间的关系决定了递归的路径

* 为什么之前无法理解递归？
>1. 不理解递归的执行过程、算法
>2. 混淆算法的执行过程、算法、算法的伪代码

### 算法思想

* 任何一个算法思想都只有一个执行过程

* 深度优先搜索是算法，还是算法思想？假如是算法思想，为什么有执行过程？假如是算法，为什么包括前/中/后序遍历算法？
>1. 是一种算法思想，因为算法思想是可以有对应的执行过程的

* 从概念上讲，深度优先搜索和前序遍历的关系是什么？
>1. 深度优先搜索是一种算法思想，前序遍历是一种先处理根，再处理左右子树的遍历
>2. 对于一棵树，根据搜索方式的不同，分为深度优先搜索和广度优先搜索；根据搜索过程中处理根，左右子节点顺序的不同，分为前序遍历、中序遍历和后序遍历
>3. 前序、中序和后续遍历的搜索方式都是深度优先搜索
>4. 因此，深度优先搜索算法包括前序、中序和后序遍历算法
>5. 综上所述，对于遍历一棵树的算法，要么是深度优先搜索算法，要么是广度优先搜索算法。假如是深度优先搜索算法，那么可能是前序、中序或后序算法

* ~~为什么会想不清上述问题，进而给出错误的答案？~~
>1. ~~对图的基本操作理解不够具体。只想到了遍历，但没理解到dfs和bfs这一层~~
>2. ~~对递归的理解不充分，进而无法识别递归和dfs的关系~~

* ~~深度优先搜索是算法，还是算法思想？假如是算法思想，为什么有执行过程？假如是算法，为什么包括前/中/后序遍历算法？~~
>1. ~~都不是，深度优先搜索是对图的一种基本操作~~

* ~~从概念上讲，深度优先搜索和前序遍历的关系是什么？~~
>1. ~~深度优先搜索包括前序遍历、中序遍历和后序遍历~~

* ~~算法思想有对应的执行过程吗？假如有，和具体算法的执行过程的区别和联系是什么？~~
>1. ~~任何一种算法思想都是有对应的执行过程的~~
>2. ~~这些执行过程的逻辑规定了具体算法的执行过程的整体逻辑，区别仅在于逻辑中某些部分是抽象的，省略了内部逻辑~~