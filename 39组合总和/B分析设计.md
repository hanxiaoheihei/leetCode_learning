## 题目分析

* 为了解决该问题，可以采用的基本想法是什么？

  > 1. 用target不断去减候选数组中的数字。

* 基于上述基本想法，在如下案例中，解决该问题的计算过程是什么？对计算过程分析，可得出哪些结论？基于计算过程和分析结论，如果解决这种情况下的该问题？

  | 案例名称 | 过程分析结论                                                 | 计算规则                                                     |
  | -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
  | 示例1    | 节点值为target和数组值的差；路径权重是数组值；当节点值为0时，取得目标结果；当节点值<0时，取不到目标结果；不同路径的结果值可能相同 | 如果节点值为0；则该路径上的所有权重值构成一个结果；如果节点值<0；则该路径上的所有权重值不构成一个结果；如果结果中存在重复的值，则只取其中一个值 |
  |          |                                                              | 假如采用回溯的方法，那么如果节点值大于0，则继续向下遍历；如果节点值等于0，则将该节点的路径加入结果集并回溯上一节点；如果节点值小于0，则回溯至上一节点 |
  | 示例2    | 同示例1                                                      | 同示例1                                                      |
  | 示例3    | 同示例1                                                      | 同示例1                                                      |
  | 示例4    | 同示例1                                                      | 同示例1                                                      |
  | 示例5    | 同示例1                                                      | 同示例1                                                      |

* 归纳总结上述计算规则，如何解决该问题？

  > 1. 采用回溯的方法。如果节点值大于0，则继续向下遍历；如果节点值等于0，则将该节点的路径加入结果集并回溯上一节点；如果节点值小于0，则回溯至上一节点
  > 2. 如果结果集中存在重复的值，则只取其中一个值

* 如何用代码实现上述计算规则？

  ```java
  //回溯算法基本框架代码
  public void dfs(TreeNode root, List<> res){
      if (){return ...};
      res.add();
      dfs(root更新值, res);
      res.remove();
  }
  
  //详细代码
  public void dfs(int target, List<List<int>> res){
      if (target < 0){ return; }
      if (target == 0){ 
          resList.add(new ArrayList<>(res));
          return;
      }
      for ( int candidate : candidates){
          res.add(candidate);
          dfs(target-candidate, res);
          res.removeLast();
      }
  }
  
  public class Solution{
      public List<List<int>> combinationSum(int[] candidates, int target){
          List<List<int>> resList = new ArrayList<>();
          dfs(target, new ArrayList<>());
          return resList;
      }
  }
  ```

* 上述代码中，存在哪些缺陷？

  > 1. 结果集中存在重复值
  > 2. 存在可剪枝的空间

* 如何解决上述代码的缺陷1？
* 基于上述分析，如何改进上述代码？